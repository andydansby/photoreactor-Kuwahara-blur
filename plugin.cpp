// plugin.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include "IPlugin.h"

#include <math.h>
#include <cmath>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>//to use cout
#include <algorithm>

using namespace std;


////////////////////////////////////////////////////////////////////////
// A concrete plugin implementation
////////////////////////////////////////////////////////////////////////

// Photo-Reactor Plugin class

//****************************************************************************
//This code has been generated by the Mediachance photo reactor Code generator.


#define AddParameter(N,S,V,M1,M2,T,D) {strcpy (pParameters[N].m_sLabel,S);pParameters[N].m_dValue = V;pParameters[N].m_dMin = M1;pParameters[N].m_dMax = M2;pParameters[N].m_nType = T;pParameters[N].m_dSpecialValue = D;}

#define GetValue(N) (pParameters[N].m_dValue)
#define GetValueY(N) (pParameters[N].m_dSpecialValue)

#define SetValue(N,V) {pParameters[N].m_dValue = V;}

#define GetBOOLValue(N) ((BOOL)(pParameters[N].m_dValue==pParameters[N].m_dMax))

// if it is not defined, then here it is
//#define RGB(r,g,b) ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16)))

#define PARAM_RADIUS	0
#define PARAM_KUWAHARA_TYPE		1

#define NUMBER_OF_USER_PARAMS 2

#define MIN(a,b) (((a)<(b))?(a):(b))
#define MAX(a,b) (((a)>(b))?(a):(b))


class Plugin1 : public IPlugin	
{
public:

		//Plugin Icon:
	//you can add your own icon by creating 160x100 png file, naming it the same as plugin dll and then placing it in the plugins folder
	//otherwise a generic icon will be use


	//this is the title of the box in workspace. it should be short
	const char* GetTitle () const
	{
		return "Kuwahara";
	}
	
	// this will appear in the help pane, you can put your credits and short info
	const char* GetDescription () const
	{
		return "Andy Dansby's version of Kuwahara.  Given an odd sized kernel, the kernel is split in 4 quadrants, each overlapping on their edges and center.  The quadrant with the lowest variance is measured and the center pixel is set to the mean of that quadrant.  The larger the kernel, the more abstract the image will become.  Perform a 1:1 zoom to see the image rendered correctly.";
	}

	// BASIC PARAMETERS
	// number of inputs 0,1 or 2
	int GetInputNumber ()
	{
		return 1;
	}

	// number of outputs 0 or 1
	int GetOutputNumber ()
	{
		return 1;
	}

	int GetBoxColor ()
	{
		return RGB(44,78,119);
	}

	int GetTextColor ()
	{
		return RGB(165,236,255);
	}

	// width of the box in the workspace
	// valid are between 50 and 100
	int GetBoxWidth ()
	{
		return 100;
	}

	// set the flags
	// see the interface builder
	// ex: nFlag = FLAG_FAST_PROCESS | FLAG_HELPER;

	//FLAG_NONE same as zero	Default, no other flags set
	//FLAG_UPDATE_IMMEDIATELY	It is very fast process that can update immediately. When user turns the sliders on UI the left display will update
	//							Use Update Immediately only for fast and single loop processes, for example Desaturate, Levels.
	//FLAG_HELPER				It is an helper object. Helper objects will remain visible in Devices and they can react to mouse messages. Example: Knob, Monitor, Bridge Pin
	//FLAG_BINDING				Binding object, attach to other objects and can change its binding value. It never goes to Process_Data functions.  Example: Knob, Switch, Slider
	//FLAG_DUMMY				It is only for interface but never process any data. Never goes to Process_Data functions. Example: Text note
	//FLAG_SKIPFINAL			Process data only during designing, doesn't process during final export. Example: Monitor, Vectorscope 
	//FLAG_LONGPROCESS			Process that takes > 1s to finish. Long Process will display the Progress dialog and will prevent user from changing values during the process.
	//FLAG_NEEDSIZEDATA		    Process need to know size of original image, the zoom and what part of image is visible in the preview. When set the plugin will receive SetSizeData
	//FLAG_NEEDMOUSE			Process will receive Mouse respond data from the workplace. This is only if your object is interactive, for example Knob, Slider

	int GetFlags ()
	{
		// it is fast process
		int nFlag = FLAG_LONGPROCESS;
		//int nFlag = FLAG_NONE;// placed temp
		
		return nFlag;
	}


	// User Interface Build
	// there is maximum 29 Parameters

	int GetUIParameters (UIParameters* pParameters)
	{

		// label, value, min, max, type_of_control, special_value
		// use the UI builder in the software to generate this

		AddParameter( PARAM_RADIUS ,"Radius", 3, 1, 30, TYPE_SLIDER, 0.0);
		AddParameter( PARAM_KUWAHARA_TYPE ,"Kuwahara|Variation", 0, 0, 1, TYPE_ONEOFMANY, 0);

		return NUMBER_OF_USER_PARAMS;
	}
	

	void basic_count_sort(BYTE * inarray, int size) 
	{
		int i, j, k;
		int index = 0;
		int min, max;
 
		min = max = inarray[0];
		for(i = 1; i < size; i++) 
		{
			min = (inarray[i] < min) ? inarray[i] : min;
			max = (inarray[i] > max) ? inarray[i] : max;
		}
 
		k = max - min + 1;
		/* creates k buckets */
		int *B = new int [k]; 
		for(i = 0; i < k; i++) B[i] = 0;

		for(i = 0; i < size; i++) B[inarray[i] - min]++;
		for(i = min; i <= max; i++) 
			for(j = 0; j < B[i - min]; j++) inarray[index++] = i;

		delete [] B;
	}


	virtual void Process_Data (BYTE* pBGRA_out,BYTE* pBGRA_in, int nWidth, int nHeight, UIParameters* pParameters)
	{
		//List of Parameters
		double dRadius = GetValue(PARAM_RADIUS);// used to grab radius from control
		int nKuwaharaType = (int)GetValue(PARAM_KUWAHARA_TYPE);


		int radius = (int)dRadius;//convert radius to an interger
		int size = (radius + radius) + 1;// we want an odd sized kernel //int size = (radius * 2) + 1;
		//int JunkVariableToTestIfCPPCheckIsAwake = 0;

		//marches through the image, along the height and then the width.
		for(int y = 0; y < nHeight; y++)//for(int y = 0; y < nHeight; y++)
		{
			for(int x = 0; x < nWidth; x++)//for(int x = 0; x < nWidth; x++)
			{
				//small array for each kernel to grab each value, 
				//this will be passed on to another array that adjust its size
				//if you are on the borders of the image
				BYTE* Rkernelarray = new BYTE[size*size]; // Red kernel array
				BYTE* Gkernelarray = new BYTE[size*size]; // Green kernel array
				BYTE* Bkernelarray = new BYTE[size*size]; // Blue kernel array
				int elementsinarray = 0;

				int flexHorizontalKernelSize = 0;//needed when cycling thru smaller kernels generated at edges
				//we will need a flex size for horizontal and vertical since they can vary on the edges

				//This is our Kernel
				//collect pixels of each color into seperate arrays
				for(int i = max(0, x - radius); i <= min(nWidth - 1, x + radius); i++)
				{
					for(int j = max(0, y - radius); j <= MIN(nHeight - 1, y + radius); j++)
					{
						//this slides / moves along the kernel to collect the neighboring pixels
						int redKernelSlider   = pBGRA_in[(i + j * nWidth) * 4 + CHANNEL_R];
						int greenKernelSlider = pBGRA_in[(i + j * nWidth) * 4 + CHANNEL_G];
						int blueKernelSlider  = pBGRA_in[(i + j * nWidth) * 4 + CHANNEL_B];
						//this slides / moves along the kernel to collect the neighboring pixels

						Rkernelarray[elementsinarray] = redKernelSlider;
						Gkernelarray[elementsinarray] = greenKernelSlider;
						Bkernelarray[elementsinarray] = blueKernelSlider;

						elementsinarray ++; // this counts how many items we place into the first array
											// at the borders, this will be a different size from the
											// kernel
					}//end J
					flexHorizontalKernelSize ++; // this measures how large the array will be horizonally
				}//end I

				int flexVerticalKernelSize = elementsinarray / flexHorizontalKernelSize;
				// to find the vertical size of the array, we will divide the elements in the array
				// or the sum of all of the elements against the flexHorizontalKernel size.

				// these arrays adjust to the size of the actual number of pixels in the kernel
				// so if you are on the border, which will not be the radius specified by the size
				// variable, as the kernel moves away from the edges of the image, the below arrays 
				// will resize accordingly.  When completey away from the edges, it will be the full
				// radius specified in size.

				BYTE* RArray = new BYTE[elementsinarray]; // kernel array
				BYTE* GArray = new BYTE[elementsinarray]; // kernel array
				BYTE* BArray = new BYTE[elementsinarray]; // kernel array

				//at the edges of the image, the kernel size does not match to the selected size
				//we present another array series.  If you are at the edges, the new array will be
				//smaller, away from the edges the kernel array is the same size.  This routine
				//just copies valad pixels
				for(int i = 0; i < elementsinarray; i++)
				{
					RArray[i] = Rkernelarray[i];
					GArray[i] = Gkernelarray[i];
					BArray[i] = Bkernelarray[i];
				}
				
				// lets delete the original arrays (since they are no longer needed) and free memory
				delete [] (BYTE*) Rkernelarray;
				delete [] (BYTE*) Gkernelarray;
				delete [] (BYTE*) Bkernelarray;

				// The below routine is used to perform a check to see if the pixels were gathered properly
				//only uncomment if you want to see how it works, and only if you have a valad array to compare it against
				/*
				{
					//just print pixels in kernel, for testing only //ok to this point
					for(int j = 0; j < flexHorizontalKernelSize; j++)//for(int j = 0; j < size; j++)
					{
						for(int i = 0; i < flexVerticalKernelSize; i++)//for(int i = 0; i < size; i++)
						{
							redpixel   = RArray[(j * flexVerticalKernelSize) + i];
							greenpixel = GArray[(j * flexVerticalKernelSize) + i];
							bluepixel  = BArray[(j * flexVerticalKernelSize) + i];

							
							if (y > 3 & x > 3)
							{
							char sBuffer1[200]; sprintf(sBuffer1,"j = %d \n" "i = %d \n""x = %d \n" "y = %d \n" "flexHorizontalKernelSize = %d \n" "flexVerticalKernelSize = %d \n" "elementsinarray = %d \n" "redpixel = %d"
							,
							j, i, x, y, flexHorizontalKernelSize, flexVerticalKernelSize, elementsinarray, redpixel);MessageBox(NULL,sBuffer1,"ENTIRE KERNEL", MB_OK);
							}
						}
					}
					if (y > 3 & x > 3) {char sBuffer22[200]; sprintf(sBuffer22,"STOP");MessageBox(NULL,sBuffer22,"STOP", MB_OK);}
				}
				*/



				{
					//now we have the 4 sections of Kuwahara
					int area1meandivisor = 1;
					int area2meandivisor = 1;
					int area3meandivisor = 1;
					int area4meandivisor = 1;

					//sum of each area and each color
					int RedArea1Sum = 0;
					int RedArea2Sum = 0;
					int RedArea3Sum = 0;
					int RedArea4Sum = 0;

					int GreenArea1Sum = 0;
					int GreenArea2Sum = 0;
					int GreenArea3Sum = 0;
					int GreenArea4Sum = 0;

					int BlueArea1Sum = 0;
					int BlueArea2Sum = 0;
					int BlueArea3Sum = 0;
					int BlueArea4Sum = 0;
					//sum of each area and each color

					//minimum color of each area and each color
					int RedArea1Min = 65535;
					int RedArea2Min = 65535;
					int RedArea3Min = 65535;
					int RedArea4Min = 65535;

					int GreenArea1Min = 65535;
					int GreenArea2Min = 65535;
					int GreenArea3Min = 65535;
					int GreenArea4Min = 65535;

					int BlueArea1Min = 65535;
					int BlueArea2Min = 65535;
					int BlueArea3Min = 65535;
					int BlueArea4Min = 65535;
					//minimum color of each area and each color

					//maximum color of each area and each color
					int RedArea1Max = 0;
					int RedArea2Max = 0;
					int RedArea3Max = 0;
					int RedArea4Max = 0;

					int GreenArea1Max = 0;
					int GreenArea2Max = 0;
					int GreenArea3Max = 0;
					int GreenArea4Max = 0;

					int BlueArea1Max = 0;
					int BlueArea2Max = 0;
					int BlueArea3Max = 0;
					int BlueArea4Max = 0;
					//maximum color of each area and each color

					//Variance of each area and each color
					int RedArea1Variance = 0;
					int RedArea2Variance = 0;
					int RedArea3Variance = 0;
					int RedArea4Variance = 0;

					int GreenArea1Variance = 0;
					int GreenArea2Variance = 0;
					int GreenArea3Variance = 0;
					int GreenArea4Variance = 0;

					int BlueArea1Variance = 0;
					int BlueArea2Variance = 0;
					int BlueArea3Variance = 0;
					int BlueArea4Variance = 0;
					//Variance of each area and each color

					//Area 1 (lower left)
					//adjust the kernel
					int halfhorizontal = (flexHorizontalKernelSize / 2) + 1;// chop the kernel in half horizontally
					int halfvertical = (flexVerticalKernelSize / 2) + 1;// chop the kernel in half vertically					
					for(int j = 0; j < halfhorizontal; j++)
					{
						for(int i = 0; i < halfvertical; i++)
						{
							//used to calculate the sum of the pixels in the kernel in area 1
							int redpixel   = RArray[(j * flexVerticalKernelSize) + i];
							int greenpixel = GArray[(j * flexVerticalKernelSize) + i];
							int bluepixel  = BArray[(j * flexVerticalKernelSize) + i];

							//sum of the pixels in the kernel in area 1
							RedArea1Sum   += redpixel;
							GreenArea1Sum += greenpixel;
							BlueArea1Sum  += bluepixel;

							//find the largest value in the kernel in area 1
							if (RedArea1Max   < redpixel  ) RedArea1Max   = redpixel;
							if (GreenArea1Max < greenpixel) GreenArea1Max = greenpixel;
							if (BlueArea1Max  < bluepixel ) BlueArea1Max  = bluepixel;

							//find the smallest value in the kernel in area 1
							if (RedArea1Min   > redpixel  ) RedArea1Min   = redpixel;
							if (GreenArea1Min > greenpixel) GreenArea1Min = greenpixel;
							if (BlueArea1Min  > bluepixel ) BlueArea1Min  = bluepixel;

							

							//this is used to calculate how many items are in the kernel
							area1meandivisor++;
							// on the borders of the image one area is not the same size 
							// as another area, so we have to calculate each area's divisor 
							// to obtain the mean of each area.
						}
					}

					//Area 2 (lower right)
					//readjust the kernel
					halfhorizontal = (flexHorizontalKernelSize / 2);// chop the kernel in half horizontally
					halfvertical = (flexVerticalKernelSize / 2) + 1;// chop the kernel in half vertically					
					for(int j = halfhorizontal; j < flexHorizontalKernelSize; j++)
					{
						for(int i = 0; i < halfvertical; i++)
						{
							//used to calculate the sum of the pixels in the kernel in area 2
							int redpixel   = RArray[(j * flexVerticalKernelSize) + i];
							int greenpixel = GArray[(j * flexVerticalKernelSize) + i];
							int bluepixel  = BArray[(j * flexVerticalKernelSize) + i];

							//sum of the pixels in the kernel in area 2
							RedArea2Sum   += redpixel;
							GreenArea2Sum += greenpixel;
							BlueArea2Sum  += bluepixel;

							//find the largest value in the kernel in area 2
							if (RedArea2Max   < redpixel  ) RedArea2Max   = redpixel;
							if (GreenArea2Max < greenpixel) GreenArea2Max = greenpixel;
							if (BlueArea2Max  < bluepixel ) BlueArea2Max  = bluepixel;

							//find the smallest value in the kernel in area 2
							if (RedArea2Min   > redpixel  ) RedArea2Min   = redpixel;
							if (GreenArea2Min > greenpixel) GreenArea2Min = greenpixel;
							if (BlueArea2Min  > bluepixel ) BlueArea2Min  = bluepixel;

							area2meandivisor++;
							// on the borders of the image one area is not the same size 
							// as another area, so we have to calculate each area's divisor 
							// to obtain the mean of each area.
						}
					}

					//Area 3 (upper left)
					//readjust the kernel
					halfhorizontal = (flexHorizontalKernelSize / 2) + 1;// chop the kernel in half horizontally
					halfvertical = (flexVerticalKernelSize / 2);// chop the kernel in half vertically					
					for(int j = 0; j < halfhorizontal; j++)
					{
						for(int i = halfvertical; i < flexVerticalKernelSize; i++)
						{
							//used to calculate the sum of the pixels in the kernel in area 3
							int redpixel   = RArray[(j * flexVerticalKernelSize) + i];
							int greenpixel = GArray[(j * flexVerticalKernelSize) + i];
							int bluepixel  = BArray[(j * flexVerticalKernelSize) + i];

							//sum of the pixels in the kernel in area 3
							RedArea3Sum   += redpixel;
							GreenArea3Sum += greenpixel;
							BlueArea3Sum  += bluepixel;

							//find the largest value in the kernel in area 3
							if (RedArea3Max   < redpixel  ) RedArea3Max   = redpixel;
							if (GreenArea3Max < greenpixel) GreenArea3Max = greenpixel;
							if (BlueArea3Max  < bluepixel ) BlueArea3Max  = bluepixel;

							//find the smallest value in the kernel in area 3
							if (RedArea3Min   > redpixel  ) RedArea3Min   = redpixel;
							if (GreenArea3Min > greenpixel) GreenArea3Min = greenpixel;
							if (BlueArea3Min  > bluepixel ) BlueArea3Min  = bluepixel;

							area3meandivisor++;
							// on the borders of the image one area is not the same size 
							// as another area, so we have to calculate each area's divisor 
							// to obtain the mean of each area.
						}
					}

					//Area 4 (upper right)
					//readjust the kernel
					halfhorizontal = (flexHorizontalKernelSize / 2);// chop the kernel in half horizontally
					halfvertical = (flexVerticalKernelSize / 2);// chop the kernel in half vertically					
					for(int j = halfhorizontal; j < flexHorizontalKernelSize; j++)
					{
						for(int i = halfvertical; i < flexVerticalKernelSize; i++)
						{
							//used to calculate the sum of the pixels in the kernel in area 4
							int redpixel   = RArray[(j * flexVerticalKernelSize) + i];
							int greenpixel = GArray[(j * flexVerticalKernelSize) + i];
							int bluepixel  = BArray[(j * flexVerticalKernelSize) + i];

							//sum of the pixels in the kernel in area 4
							RedArea4Sum   += redpixel;
							GreenArea4Sum += greenpixel;
							BlueArea4Sum  += bluepixel;

							//find the largest value in the kernel in area 4
							if (RedArea4Max   < redpixel  ) RedArea4Max   = redpixel;
							if (GreenArea4Max < greenpixel) GreenArea4Max = greenpixel;
							if (BlueArea4Max  < bluepixel ) BlueArea4Max  = bluepixel;

							//find the smallest value in the kernel in area 4
							if (RedArea4Min   > redpixel  ) RedArea4Min   = redpixel;
							if (GreenArea4Min > greenpixel) GreenArea4Min = greenpixel;
							if (BlueArea4Min  > bluepixel ) BlueArea4Min  = bluepixel;

							area4meandivisor++;
							// on the borders of the image one area is not the same size 
							// as another area, so we have to calculate each area's divisor 
							// to obtain the mean of each area.
						}
					}


					//we are now going to calculate the variance, which is the difference between the max and min pixel level					
					RedArea1Variance = (RedArea1Max - RedArea1Min);
					RedArea2Variance = (RedArea2Max - RedArea2Min);
					RedArea3Variance = (RedArea3Max - RedArea3Min);
					RedArea4Variance = (RedArea4Max - RedArea4Min);

					GreenArea1Variance = (GreenArea1Max - GreenArea1Min);
					GreenArea2Variance = (GreenArea2Max - GreenArea2Min);
					GreenArea3Variance = (GreenArea3Max - GreenArea3Min);
					GreenArea4Variance = (GreenArea4Max - GreenArea4Min);

					BlueArea1Variance = (BlueArea1Max - BlueArea1Min);
					BlueArea2Variance = (BlueArea2Max - BlueArea2Min);
					BlueArea3Variance = (BlueArea3Max - BlueArea3Min);
					BlueArea4Variance = (BlueArea4Max - BlueArea4Min);
					

					/*
					In each of the four regions (a, b, c, d), the mean brightness and the variance are calculated. 
					The output value of the center pixel (abcd) in the window is the mean value of that region 
					that has the smallest variance. 
					This filter is an edge-preserving filter, which smoothes the images without disturbing the 
					sharpness and the position of edges.
					*/


					//print the statistics
					/*
					char sBuffer6[400]; sprintf(sBuffer6,"RedArea1Max = %d \n" "RedArea1Min = %d \n\n" "RedArea2Max = %d \n" 
					"RedArea2Min = %d \n\n" "RedArea3Max = %d \n" "RedArea3Min = %d \n\n" "RedArea4Max = %d \n" "RedArea4Min = %d\n\n"
					"RedArea1Variance = %d \n" "RedArea2Variance = %d \n" "RedArea3Variance = %d \n" "RedArea4Variance = %d \n"
					,
					RedArea1Max, RedArea1Min, RedArea2Max, RedArea2Min, 
					RedArea3Max, RedArea3Min, RedArea4Max,RedArea4Min,
					RedArea1Variance, RedArea2Variance, RedArea3Variance, RedArea4Variance				
					);
				
					MessageBox(NULL,sBuffer6,"min and max", MB_OK);
					*/

					//Find out which regions has the least variance
					int redMean = 0;
					int greenMean = 0;
					int blueMean = 0;

					{
						int areawithsmallestdifference = 1;

						int area1difference = RedArea1Variance + GreenArea1Variance + BlueArea1Variance;
						int area2difference = RedArea2Variance + GreenArea2Variance + BlueArea2Variance;
						int area3difference = RedArea3Variance + GreenArea3Variance + BlueArea3Variance;
						int area4difference = RedArea4Variance + GreenArea4Variance + BlueArea4Variance;

						if (nKuwaharaType == 0)
						{
							if (area1difference < area2difference && area3difference && area4difference)
							{
								areawithsmallestdifference = 1;
							}
						
							if (area2difference < area1difference && area3difference && area4difference)
							{
								areawithsmallestdifference = 2;
							}
						
							if (area3difference < area1difference && area2difference && area4difference)
							{
								areawithsmallestdifference = 3;
							}
						
							if (area4difference < area1difference && area2difference && area3difference)
							{
								areawithsmallestdifference = 4;
							}
						}						

						if (nKuwaharaType == 1)
						{
							if (area1difference < area2difference && area1difference < area3difference && area1difference < area4difference)
							{
								areawithsmallestdifference = 1;
							}
							else
							if (area2difference < area1difference && area2difference < area3difference && area2difference < area4difference)
							{
								areawithsmallestdifference = 2;
							}
							else
							if (area3difference < area1difference && area3difference < area2difference && area3difference < area4difference)
							{
								areawithsmallestdifference = 3;
							}
							else
							if (area4difference < area1difference && area4difference < area2difference && area4difference < area3difference)
							{
								areawithsmallestdifference = 4;
							}
						}








						if (nKuwaharaType == 98)
						{
							if (area1difference < area2difference && area1difference < area3difference && area1difference < area4difference)
							{
								areawithsmallestdifference = 1;
							}
							else
							if (area2difference < area1difference && area2difference < area3difference && area2difference < area4difference)
							{
								areawithsmallestdifference = 2;
							}
							else
							if (area3difference < area1difference && area3difference < area2difference && area3difference < area4difference)
							{
								areawithsmallestdifference = 3;
							}
							else
							if (area4difference < area1difference && area4difference < area2difference && area4difference < area3difference)
							{
								areawithsmallestdifference = 4;
							}
						}

						if (nKuwaharaType == 99)
						{
							if (area1difference < area2difference && area3difference && area4difference)
							{
								areawithsmallestdifference = 1;
							}
							else
							if (area2difference < area1difference && area3difference && area4difference)
							{
								areawithsmallestdifference = 2;
							}
							else
							if (area3difference < area1difference && area2difference && area4difference)
							{
								areawithsmallestdifference = 3;
							}
							else
							if (area4difference < area1difference && area2difference && area3difference)
							{
								areawithsmallestdifference = 4;
							}
						}

						



						//char sBuffer6[400]; sprintf(sBuffer6,"areawithsmallestdifference %d \n", areawithsmallestdifference);MessageBox(NULL,sBuffer6,"variance", MB_OK);

						//now that we know which area has the least variance, now we can calculate the mean for that area.
						if (areawithsmallestdifference == 1)
						{
							redMean = RedArea1Sum / area1meandivisor;
							greenMean = GreenArea1Sum / area1meandivisor;
							blueMean = BlueArea1Sum / area1meandivisor;
						}
						else 
						if (areawithsmallestdifference == 2)
						{
							redMean = RedArea2Sum / area2meandivisor;
							greenMean = GreenArea2Sum / area2meandivisor;
							blueMean = BlueArea2Sum / area2meandivisor;
						}
						else
						if (areawithsmallestdifference == 3)
						{
							redMean = RedArea3Sum / area3meandivisor;
							greenMean = GreenArea3Sum / area3meandivisor;
							blueMean = BlueArea3Sum / area3meandivisor;
						}
						else
						if (areawithsmallestdifference == 4)
						{
							redMean = RedArea4Sum / area4meandivisor;
							greenMean = GreenArea4Sum / area4meandivisor;
							blueMean = BlueArea4Sum / area4meandivisor;
						}

					}


					int rKuwahara = CLAMP255(redMean);
					int gKuwahara = CLAMP255(greenMean);
					int bKuwahara = CLAMP255(blueMean);
					
					{//output
						pBGRA_out[(x + y * nWidth) * 4 + CHANNEL_R] = rKuwahara;
						pBGRA_out[(x + y * nWidth) * 4 + CHANNEL_G] = gKuwahara;
						pBGRA_out[(x + y * nWidth) * 4 + CHANNEL_B] = bKuwahara;
					}//end output


				}


				delete [] (BYTE*) RArray;
				delete [] (BYTE*) GArray;
				delete [] (BYTE*) BArray;
			}//end X
		}//end Y

#pragma endregion

	}//end routine

						


	// actual processing function for 2 inputs
	//********************************************************************************
	// all buffers are the same size
	// don't change the IN buffers or things will go bad
	// the pBGRA_out comes already with copied data from pBGRA_in1
	virtual void Process_Data2 (BYTE* pBGRA_out, BYTE* pBGRA_in1, BYTE* pBGRA_in2, int nWidth, int nHeight, UIParameters* pParameters)
	{

	}


	//*****************Drawing functions for the BOX *********************************
	//how is the drawing handled
	//DRAW_AUTOMATICALLY	the main program will fully take care of this and draw a box, title, socket and thumbnail
	//DRAW_SIMPLE_A			will draw a box, title and sockets and call CustomDraw
	//DRAW_SIMPLE_B			will draw a box and sockets and call CustomDraw
	//DRAW_SOCKETSONLY      will call CustomDraw and then draw sockets on top of it
	
	// highlighting rectangle around is always drawn except for DRAW_SOCKETSONLY

	virtual int GetDrawingType ()
	{
		int nType = DRAW_AUTOMATICALLY;

		return nType;
	}


	// Custom Drawing
	// custom drawing function called when drawing type is different than DRAW_AUTOMATICALLY
	// it is not always in real pixels but scaled depending on where it is drawn
	// the scale could be from 1.0 to > 1.0
	// so you always multiply the position, sizes, font size, line width with the scale
	
	virtual void CustomDraw (HDC hDC, int nX,int nY, int nWidth, int nHeight, float scale, BOOL bIsHighlighted, UIParameters* pParameters)
	{
	}


	//************ Optional Functions *****************************************************************************************
	// those functions are not necessary for normal effect, they are mostly for special effects and objects


	// Called when FLAG_HELPER set. 
	// When UI data changed (user turned knob) this function will be called as soon as user finish channging the data
	// You will get the latest parameters and also which parameter changed
	// Normally for effects you don't have to do anything here because you will get the same parameters in the process function
	// It is only for helper objects that may not go to Process Data 
	BOOL UIParametersChanged (UIParameters* pParameters, int nParameter)
	{
		
		return FALSE;
	}

	// when button is pressed on UI, this function will be called with the parameter and sub button (for multi button line)
	BOOL UIButtonPushed (int nParam, int nSubButton, UIParameters* pParameters)
	{

		return TRUE;
	}


	// Called when FLAG_NEEDSIZEDATA set
	// Called before each calculation (Process_Data)
	// If your process depends on a position on a frame you may need the data to correctly display it because Process_Data receives only a preview crop
	// Most normal effects don't depend on the position in frame so you don't need the data
	// Example: drawing a circle at a certain position requires to know what is displayed in preview or the circle will be at the same size and position regardless of zoom
	
	// Note: Even if you need position but you don't want to mess with the crop data, just ignore it and pretend the Process_Data are always of full image (they are not). 
	// In worst case this affects only preview when using zoom. The full process image always sends the whole data

	// nOriginalW, nOriginalH - the size of the original - full image. If user sets Resize on input - this will be the resized image
	// nPreviewW, nPreviewH   - this is the currently processed preview width/height - it is the same that Process_Data will receive
	//                        - in full process the nPreviewW, nPreviewH is equal nOriginalW, nOriginalH
	// Crop X1,Y1,X2,Y2       - relative coordinates of preview crop rectangle in <0...1>, for full process they are 0,0,1,1 (full rectangle)	
	// dZoom                  - Zoom of the Preview, for full process the dZoom = 1.0
	void SetSizeData(int nOriginalW, int nOriginalH, int nPreviewW, int nPreviewH, double dCropX1, double dCropY1, double dCropX2, double dCropY2, double dZoom)
	{

		// so if you need the position and zoom, this is the place to get it.
		// Note: because of IBM wisdom the internal bitmaps are on PC always upside down, but the coordinates are not


	}


	// ***** Mouse handling on workplace *************************** 
	// only if FLAG_NEEDMOUSE is set
	//****************************************************************
	//this is for special objects that need to receive mouse, like a knob or slider on workplace
	// normally you use this for FLAG_BINDING objects

	// in coordinates relative to top, left corner of the object (0,0)
	virtual BOOL MouseButtonDown (int nX, int nY, int nWidth, int nHeight, UIParameters* pParameters)
	{
		
		// return FALSE if not handled
		// return TRUE if handled
		return FALSE;
	}

	// in coordinates relative to top, left corner of the object (0,0)
	virtual BOOL MouseMove (int nX, int nY, int nWidth, int nHeight, UIParameters* pParameters)
	{
	

		return FALSE;
	}
	
	// in coordinates relative to top, left corner of the object (0,0)
	virtual BOOL MouseButtonUp (int nX, int nY, int nWidth, int nHeight, UIParameters* pParameters)
	{
		
		// Note: if we changed data and need to recalculate the flow we need to return TRUE

		// return FALSE if not handled
		// return TRUE if handled
		
		return TRUE;
	}


};

extern "C"
{
	// Plugin factory function
	__declspec(dllexport) IPlugin* Create_Plugin ()
	{
		//allocate a new object and return it
		return new Plugin1 ();
	}
	
	// Plugin cleanup function
	__declspec(dllexport) void Release_Plugin (IPlugin* p_plugin)
	{
		//we allocated in the factory with new, delete the passed object
		delete p_plugin;
	}
	
}


// this is the name that will appear in the object library
extern "C" __declspec(dllexport) char* GetPluginName()
{
	return "Andys 2d Kuwahara";	
}


// This MUST be unique string for each plugin so we can save the data

extern "C" __declspec(dllexport) char* GetPluginID()
{
	return "com.lumafilters.Kuwahara";	
}


// category of plugin, for now the EFFECT go to top library box, everything else goes to the middle library box
extern "C" __declspec(dllexport) int GetCategory()
{
		
	return CATEGORY_EFFECT;
	
}